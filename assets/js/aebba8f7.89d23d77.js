"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[308],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>N});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function p(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?p(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},p=Object.keys(e);for(a=0;a<p.length;a++)t=p[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(a=0;a<p.length;a++)t=p[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),s=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",k={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,p=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=s(t),u=i,N=d["".concat(l,".").concat(u)]||d[u]||k[u]||p;return t?a.createElement(N,r(r({ref:n},m),{},{components:t})):a.createElement(N,r({ref:n},m))}));function N(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var p=t.length,r=new Array(p);r[0]=u;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[d]="string"==typeof e?e:i,r[1]=o;for(var s=2;s<p;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},4430:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>k,frontMatter:()=>p,metadata:()=>o,toc:()=>s});var a=t(7462),i=(t(7294),t(3905));const p={id:"options",title:"Options",sidebar_label:"Options"},r=void 0,o={unversionedId:"options",id:"options",title:"Options",description:"Parse options",source:"@site/docs/options.md",sourceDirName:".",slug:"/options",permalink:"/docs/options",draft:!1,tags:[],version:"current",frontMatter:{id:"options",title:"Options",sidebar_label:"Options"},sidebar:"tutorialSidebar",previous:{title:"Miscellaneous",permalink:"/docs/miscellaneous"},next:{title:"Reporting Issues",permalink:"/docs/reporting-issues"}},l={},s=[{value:"Parse options",id:"parse-options",level:2},{value:"Compress options",id:"compress-options",level:2},{value:"Mangle options",id:"mangle-options",level:2},{value:"Mangle properties options",id:"mangle-properties-options",level:3},{value:"Format options",id:"format-options",level:2}],m={toc:s},d="wrapper";function k(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"parse-options"},"Parse options"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"bare_returns")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- support top level ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statements")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"html5_comments")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),")")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"shebang")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- support ",(0,i.kt)("inlineCode",{parentName:"p"},"#!command")," as the first line")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"spidermonkey")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- accept a Spidermonkey (Mozilla) AST"))),(0,i.kt)("h2",{id:"compress-options"},"Compress options"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"defaults")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," to disable most default\nenabled ",(0,i.kt)("inlineCode",{parentName:"p"},"compress")," transforms. Useful when you only want to enable a few\n",(0,i.kt)("inlineCode",{parentName:"p"},"compress")," options while disabling the rest.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"arrows")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Class and object literal methods are converted\nwill also be converted to arrow expressions if the resultant code is shorter:\n",(0,i.kt)("inlineCode",{parentName:"p"},"m(){return x}")," becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"m:()=>x"),". To do this to regular ES5 functions which\ndon't use ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"arguments"),", see ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_arrows"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"arguments")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- replace ",(0,i.kt)("inlineCode",{parentName:"p"},"arguments[index]")," with function\nparameter name whenever possible.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"booleans")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- various optimizations for boolean context,\nfor example ",(0,i.kt)("inlineCode",{parentName:"p"},"!!a ? b : c \u2192 a ? b : c"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"booleans_as_integers")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Turn booleans into 0 and 1, also\nmakes comparisons with booleans use ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!=")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"===")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!=="),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"collapse_vars")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Collapse single-use non-constant variables,\nside effects permitting.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"comparisons")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- apply certain optimizations to binary nodes,\ne.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"!(a <= b) \u2192 a > b")," (only when ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_comps"),"), attempts to negate binary\nnodes, e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"a = !b && !c && !d && !e \u2192 a=!(b||c||d||e)")," etc. Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"comparisons"),"\nworks best with ",(0,i.kt)("inlineCode",{parentName:"p"},"lhs_constants")," enabled.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"computed_props")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Transforms constant computed properties\ninto regular ones: ",(0,i.kt)("inlineCode",{parentName:"p"},'{["computed"]: 1}')," is converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"{computed: 1}"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"conditionals")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- apply optimizations for ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),"-s and conditional\nexpressions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"dead_code")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- remove unreachable code")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"directives")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- remove redundant or non-standard directives")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"drop_console")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to discard calls to\n",(0,i.kt)("inlineCode",{parentName:"p"},"console.*")," functions. If you only want to discard a portion of console,\nyou can pass an array like this ",(0,i.kt)("inlineCode",{parentName:"p"},"['log', 'info']"),", which will only discard ",(0,i.kt)("inlineCode",{parentName:"p"},"console.log"),"\u3001 ",(0,i.kt)("inlineCode",{parentName:"p"},"console.info"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"drop_debugger")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- remove ",(0,i.kt)("inlineCode",{parentName:"p"},"debugger;")," statements")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ecma")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"2015")," or greater to enable ",(0,i.kt)("inlineCode",{parentName:"p"},"compress")," options that\nwill transform ES5 code into smaller ES6+ equivalent forms.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"evaluate")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- attempt to evaluate constant expressions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"expression")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to preserve completion values\nfrom terminal statements without ",(0,i.kt)("inlineCode",{parentName:"p"},"return"),", e.g. in bookmarklets.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"global_defs")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"{}"),") -- see ",(0,i.kt)("a",{parentName:"p",href:"/docs/miscellaneous#conditional-compilation"},"conditional compilation"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"hoist_funs")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- hoist function declarations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"hoist_props")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- hoist properties from constant object and\narray literals into regular variables subject to a set of constraints. For example:\n",(0,i.kt)("inlineCode",{parentName:"p"},"var o={p:1, q:2}; f(o.p, o.q);")," is converted to ",(0,i.kt)("inlineCode",{parentName:"p"},"f(1, 2);"),". Note: ",(0,i.kt)("inlineCode",{parentName:"p"},"hoist_props"),"\nworks best with ",(0,i.kt)("inlineCode",{parentName:"p"},"mangle")," enabled, the ",(0,i.kt)("inlineCode",{parentName:"p"},"compress")," option ",(0,i.kt)("inlineCode",{parentName:"p"},"passes")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"2")," or higher,\nand the ",(0,i.kt)("inlineCode",{parentName:"p"},"compress")," option ",(0,i.kt)("inlineCode",{parentName:"p"},"toplevel")," enabled.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"hoist_vars")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- hoist ",(0,i.kt)("inlineCode",{parentName:"p"},"var")," declarations (this is ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"\nby default because it seems to increase the size of the output in general)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"if_return")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- optimizations for if/return and if/continue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"inline")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- inline calls to function with simple/",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statement:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"false")," -- same as ",(0,i.kt)("inlineCode",{parentName:"li"},"0")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0")," -- disabled inlining"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1")," -- inline simple functions"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2")," -- inline functions with arguments"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"3")," -- inline functions with arguments and variables"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"true")," -- same as ",(0,i.kt)("inlineCode",{parentName:"li"},"3")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"join_vars")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- join consecutive ",(0,i.kt)("inlineCode",{parentName:"p"},"var"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"let")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," statements")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_classnames")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to prevent the compressor from\ndiscarding class names. Pass a regular expression to only keep class names matching\nthat regex. See also: the ",(0,i.kt)("inlineCode",{parentName:"p"},"keep_classnames")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/options#mangle-options"},"mangle option"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_fargs")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Prevents the compressor from discarding unused\nfunction arguments.  You need this for code which relies on ",(0,i.kt)("inlineCode",{parentName:"p"},"Function.length"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_fnames")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to prevent the\ncompressor from discarding function names. Pass a regular expression to only keep\nfunction names matching that regex. Useful for code relying on ",(0,i.kt)("inlineCode",{parentName:"p"},"Function.prototype.name"),".\nSee also: the ",(0,i.kt)("inlineCode",{parentName:"p"},"keep_fnames")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/options#mangle-options"},"mangle option"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_infinity")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to prevent ",(0,i.kt)("inlineCode",{parentName:"p"},"Infinity")," from\nbeing compressed into ",(0,i.kt)("inlineCode",{parentName:"p"},"1/0"),", which may cause performance issues on Chrome.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"lhs_constants")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Moves constant values to the left-hand side\nof binary nodes. ",(0,i.kt)("inlineCode",{parentName:"p"},"foo == 42 \u2192 42 == foo"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"loops")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- optimizations for ",(0,i.kt)("inlineCode",{parentName:"p"},"do"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"for")," loops\nwhen we can statically determine the condition.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"module")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," when compressing an ES6 module. Strict\nmode is implied and the ",(0,i.kt)("inlineCode",{parentName:"p"},"toplevel")," option as well.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"negate_iife")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),') -- negate "Immediately-Called Function Expressions"\nwhere the return value is discarded, to avoid the parens that the\ncode generator would insert.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"passes")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),") -- The maximum number of times to run compress.\nIn some cases more than one pass leads to further compressed code.  Keep in\nmind more passes will take more time.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"properties")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- rewrite property access using the dot notation, for\nexample ",(0,i.kt)("inlineCode",{parentName:"p"},'foo["bar"] \u2192 foo.bar'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"pure_funcs")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),") -- You can pass an array of names and\nTerser will assume that those functions do not produce side\neffects.  DANGER: will not check if the name is redefined in scope.\nAn example case here, for instance ",(0,i.kt)("inlineCode",{parentName:"p"},"var q = Math.floor(a/b)"),".  If\nvariable ",(0,i.kt)("inlineCode",{parentName:"p"},"q")," is not used elsewhere, Terser will drop it, but will\nstill keep the ",(0,i.kt)("inlineCode",{parentName:"p"},"Math.floor(a/b)"),", not knowing what it does.  You can\npass ",(0,i.kt)("inlineCode",{parentName:"p"},"pure_funcs: [ 'Math.floor' ]")," to let it know that this\nfunction won't produce any side effect, in which case the whole\nstatement would get discarded.  The current implementation adds some\noverhead (compression will be slower).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"pure_getters")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},'"strict"'),") -- If you pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," for\nthis, Terser will assume that object property access\n(e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"foo.bar")," or ",(0,i.kt)("inlineCode",{parentName:"p"},'foo["bar"]'),") doesn't have any side effects.\nSpecify ",(0,i.kt)("inlineCode",{parentName:"p"},'"strict"')," to treat ",(0,i.kt)("inlineCode",{parentName:"p"},"foo.bar")," as side-effect-free only when\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo")," is certain to not throw, i.e. not ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"pure_new")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to assume ",(0,i.kt)("inlineCode",{parentName:"p"},"new X()")," never has\nside effects.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"reduce_vars")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Improve optimization on variables assigned with and\nused as constant values.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"reduce_funcs")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Inline single-use functions when\npossible. Depends on ",(0,i.kt)("inlineCode",{parentName:"p"},"reduce_vars")," being enabled.  Disabling this option\nsometimes improves performance of the output code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"sequences")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- join consecutive simple statements using the\ncomma operator.  May be set to a positive integer to specify the maximum number\nof consecutive comma sequences that will be generated. If this option is set to\n",(0,i.kt)("inlineCode",{parentName:"p"},"true")," then the default ",(0,i.kt)("inlineCode",{parentName:"p"},"sequences")," limit is ",(0,i.kt)("inlineCode",{parentName:"p"},"200"),". Set option to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),"\nto disable. The smallest ",(0,i.kt)("inlineCode",{parentName:"p"},"sequences")," length is ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),". A ",(0,i.kt)("inlineCode",{parentName:"p"},"sequences")," value of ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"\nis grandfathered to be equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and as such means ",(0,i.kt)("inlineCode",{parentName:"p"},"200"),". On rare\noccasions the default sequences limit leads to very slow compress times in which\ncase a value of ",(0,i.kt)("inlineCode",{parentName:"p"},"20")," or less is recommended.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"side_effects")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Remove expressions which have no side effects\nand whose results aren't used.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"switches")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- de-duplicate and remove unreachable ",(0,i.kt)("inlineCode",{parentName:"p"},"switch")," branches")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"toplevel")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- drop unreferenced functions (",(0,i.kt)("inlineCode",{parentName:"p"},'"funcs"'),") and/or\nvariables (",(0,i.kt)("inlineCode",{parentName:"p"},'"vars"'),") in the top level scope (",(0,i.kt)("inlineCode",{parentName:"p"},"false")," by default, ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to drop\nboth unreferenced functions and variables)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"top_retain")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),") -- prevent specific toplevel functions and\nvariables from ",(0,i.kt)("inlineCode",{parentName:"p"},"unused")," removal (can be array, comma-separated, RegExp or\nfunction. Implies ",(0,i.kt)("inlineCode",{parentName:"p"},"toplevel"),")")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"typeofs")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- Transforms ",(0,i.kt)("inlineCode",{parentName:"p"},'typeof foo == "undefined"')," into\n",(0,i.kt)("inlineCode",{parentName:"p"},"foo === void 0"),".  Note: recommend to set this value to ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," for IE10 and\nearlier versions due to known issues.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),') -- apply "unsafe" transformations\n(',(0,i.kt)("a",{parentName:"p",href:"/docs/miscellaneous#the-unsafe-compress-option"},"details"),").")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_arrows")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Convert ES5 style anonymous function\nexpressions to arrow functions if the function body does not reference ",(0,i.kt)("inlineCode",{parentName:"p"},"this"),".\nNote: it is not always safe to perform this conversion if code relies on the\nthe function having a ",(0,i.kt)("inlineCode",{parentName:"p"},"prototype"),", which arrow functions lack.\nThis transform requires that the ",(0,i.kt)("inlineCode",{parentName:"p"},"ecma")," compress option is set to ",(0,i.kt)("inlineCode",{parentName:"p"},"2015")," or greater.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_comps")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Reverse ",(0,i.kt)("inlineCode",{parentName:"p"},"<")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<=")," to ",(0,i.kt)("inlineCode",{parentName:"p"},">")," and ",(0,i.kt)("inlineCode",{parentName:"p"},">=")," to\nallow improved compression. This might be unsafe when an at least one of two\noperands is an object with computed values due the use of methods like ",(0,i.kt)("inlineCode",{parentName:"p"},"get"),",\nor ",(0,i.kt)("inlineCode",{parentName:"p"},"valueOf"),". This could cause change in execution order after operands in the\ncomparison are switching. Compression only works if both ",(0,i.kt)("inlineCode",{parentName:"p"},"comparisons")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_comps")," are both set to true.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_Function")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- compress and mangle ",(0,i.kt)("inlineCode",{parentName:"p"},"Function(args, code)"),"\nwhen both ",(0,i.kt)("inlineCode",{parentName:"p"},"args")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"code")," are string literals.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_math")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- optimize numerical expressions like\n",(0,i.kt)("inlineCode",{parentName:"p"},"2 * x * 3")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"6 * x"),", which may give imprecise floating point results.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_symbols")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- removes keys from native Symbol\ndeclarations, e.g ",(0,i.kt)("inlineCode",{parentName:"p"},'Symbol("kDog")')," becomes ",(0,i.kt)("inlineCode",{parentName:"p"},"Symbol()"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_methods")," (default: false) -- Converts ",(0,i.kt)("inlineCode",{parentName:"p"},"{ m: function(){} }")," to\n",(0,i.kt)("inlineCode",{parentName:"p"},"{ m(){} }"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"ecma")," must be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"6")," or greater to enable this transform.\nIf ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_methods"),' is a RegExp then key/value pairs with keys matching the\nRegExp will be converted to concise methods.\nNote: if enabled there is a risk of getting a "',(0,i.kt)("inlineCode",{parentName:"p"},"<method name>"),' is not a\nconstructor" TypeError should any code try to ',(0,i.kt)("inlineCode",{parentName:"p"},"new")," the former function.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_proto")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- optimize expressions like\n",(0,i.kt)("inlineCode",{parentName:"p"},"Array.prototype.slice.call(a)")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"[].slice.call(a)"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_regexp")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- enable substitutions of variables with\n",(0,i.kt)("inlineCode",{parentName:"p"},"RegExp")," values the same way as if they are constants.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unsafe_undefined")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- substitute ",(0,i.kt)("inlineCode",{parentName:"p"},"void 0")," if there is a\nvariable named ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," in scope (variable name will be mangled, typically\nreduced to a single character)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"unused")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- drop unreferenced functions and variables (simple\ndirect variable assignments do not count as references unless set to ",(0,i.kt)("inlineCode",{parentName:"p"},'"keep_assign"'),")"))),(0,i.kt)("h2",{id:"mangle-options"},"Mangle options"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"eval")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to mangle names visible in scopes\nwhere ",(0,i.kt)("inlineCode",{parentName:"p"},"eval")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"with")," are used.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_classnames")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to not mangle class names.\nPass a regular expression to only keep class names matching that regex.\nSee also: the ",(0,i.kt)("inlineCode",{parentName:"p"},"keep_classnames")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/options#compress-options"},"compress option"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_fnames")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to not mangle function names.\nPass a regular expression to only keep function names matching that regex.\nUseful for code relying on ",(0,i.kt)("inlineCode",{parentName:"p"},"Function.prototype.name"),". See also: the ",(0,i.kt)("inlineCode",{parentName:"p"},"keep_fnames"),"\n",(0,i.kt)("a",{parentName:"p",href:"/docs/options#compress-options"},"compress option"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"module")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," an ES6 modules, where the toplevel\nscope is not the global scope. Implies ",(0,i.kt)("inlineCode",{parentName:"p"},"toplevel")," and assumes input code is strict mode JS.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"nth_identifier")," (default: an internal mangler that weights based on character\nfrequency analysis) -- Pass an object with a ",(0,i.kt)("inlineCode",{parentName:"p"},"get(n)")," function that converts an\nordinal into the nth most favored (usually shortest) identifier.\nOptionally also provide ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"sort()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"consider(chars, delta)")," to\nuse character frequency analysis of the source code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"reserved")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),") -- Pass an array of identifiers that should be\nexcluded from mangling. Example: ",(0,i.kt)("inlineCode",{parentName:"p"},'["foo", "bar"]'),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"toplevel")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to mangle names declared in the\ntop level scope.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"safari10")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to work around the Safari 10 loop\niterator ",(0,i.kt)("a",{parentName:"p",href:"https://bugs.webkit.org/show_bug.cgi?id=171041"},"bug"),'\n"Cannot declare a let variable twice".\nSee also: the ',(0,i.kt)("inlineCode",{parentName:"p"},"safari10")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/options#format-options"},"format option"),"."))),(0,i.kt)("p",null,"Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// test.js\nvar globalVar;\nfunction funcName(firstLongName, anotherLongName) {\n    var myVariable = firstLongName +  anotherLongName;\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"var code = fs.readFileSync(\"test.js\", \"utf8\");\n\nawait minify(code).code;\n// 'function funcName(a,n){}var globalVar;'\n\nawait minify(code, { mangle: { reserved: ['firstLongName'] } }).code;\n// 'function funcName(firstLongName,a){}var globalVar;'\n\nawait minify(code, { mangle: { toplevel: true } }).code;\n// 'function n(n,a){}var a;'\n")),(0,i.kt)("h3",{id:"mangle-properties-options"},"Mangle properties options"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"builtins")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") \u2014 Use ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to allow the mangling of builtin\nDOM properties. Not recommended to override this setting.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"debug")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") \u2014 Mangle names with the original name still present.\nPass an empty string ",(0,i.kt)("inlineCode",{parentName:"p"},'""')," to enable, or a non-empty string to set the debug suffix.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_quoted")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") \u2014 How quoting properties (",(0,i.kt)("inlineCode",{parentName:"p"},'{"prop": ...}')," and ",(0,i.kt)("inlineCode",{parentName:"p"},'obj["prop"]'),") controls what gets mangled."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'"strict"')," (recommended) -- ",(0,i.kt)("inlineCode",{parentName:"li"},"obj.prop")," is mangled."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"false")," -- ",(0,i.kt)("inlineCode",{parentName:"li"},'obj["prop"]')," is mangled."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"true")," -- ",(0,i.kt)("inlineCode",{parentName:"li"},"obj.prop")," is mangled unless there is ",(0,i.kt)("inlineCode",{parentName:"li"},'obj["prop"]')," elsewhere in the code."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"nth_identifer")," (default: an internal mangler that weights based on character\nfrequency analysis) -- Pass an object with a ",(0,i.kt)("inlineCode",{parentName:"p"},"get(n)")," function that converts an\nordinal into the nth most favored (usually shortest) identifier.\nOptionally also provide ",(0,i.kt)("inlineCode",{parentName:"p"},"reset()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"sort()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"consider(chars, delta)")," to\nuse character frequency analysis of the source code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"regex")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),") \u2014 Pass a ",(0,i.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp"},"RegExp literal or pattern string")," to only mangle property matching the regular expression.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"reserved")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),") \u2014 Do not mangle property names listed in the\n",(0,i.kt)("inlineCode",{parentName:"p"},"reserved")," array.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"undeclared")," (default: ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") - Mangle those names when they are accessed\nas properties of known top level variables but their declarations are never\nfound in input code. May be useful when only minifying parts of a project.\nSee ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/terser/terser/issues/397"},"#397")," for more details."))),(0,i.kt)("h2",{id:"format-options"},"Format options"),(0,i.kt)("p",null,'These options control the format of Terser\'s output code. Previously known\nas "output options".'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ascii_only")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- escape Unicode characters in strings and\nregexps (affects directives with non-ascii characters becoming invalid)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"beautify")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- (DEPRECATED) whether to beautify the output.\nWhen using the legacy ",(0,i.kt)("inlineCode",{parentName:"p"},"-b")," CLI flag, this is set to true by default.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"braces")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- always insert braces in ",(0,i.kt)("inlineCode",{parentName:"p"},"if"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"for"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"do"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"while")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"with")," statements, even if their body is a single\nstatement.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"comments")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},'"some"'),') -- by default it keeps JSDoc-style comments\nthat contain "@license", "@copyright", "@preserve" or start with ',(0,i.kt)("inlineCode",{parentName:"p"},"!"),", pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"\nor ",(0,i.kt)("inlineCode",{parentName:"p"},'"all"')," to preserve all comments, ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," to omit comments in the output,\na regular expression string (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"/^!/"),") or a function.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"ecma")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),") -- set desired EcmaScript standard version for output.\nSet ",(0,i.kt)("inlineCode",{parentName:"p"},"ecma")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"2015")," or greater to emit shorthand object properties - i.e.:\n",(0,i.kt)("inlineCode",{parentName:"p"},"{a}")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"{a: a}"),".  The ",(0,i.kt)("inlineCode",{parentName:"p"},"ecma")," option will only change the output in\ndirect control of the beautifier. Non-compatible features in your input will\nstill be output as is. For example: an ",(0,i.kt)("inlineCode",{parentName:"p"},"ecma")," setting of ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," will ",(0,i.kt)("strong",{parentName:"p"},"not"),"\nconvert modern code to ES5.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"indent_level")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"4"),")")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"indent_start")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),") -- prefix all lines by that many spaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"inline_script")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- escape HTML comments and the slash in\noccurrences of ",(0,i.kt)("inlineCode",{parentName:"p"},"<\/script>")," in strings")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_numbers")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- keep number literals as it was in original code\n(disables optimizations like converting ",(0,i.kt)("inlineCode",{parentName:"p"},"1000000")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"1e6"),")")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"keep_quoted_props")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- when turned on, prevents stripping\nquotes from property names in object literals.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"max_line_len")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- maximum line length (for minified code)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"preamble")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),") -- when passed it must be a string and\nit will be prepended to the output literally.  The source map will\nadjust for this text.  Can be used to insert a comment containing\nlicensing information, for example.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"quote_keys")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to quote all keys in literal\nobjects")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"quote_style")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),") -- preferred quote style for strings (affects\nquoted property names and directives as well):"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0")," -- prefers double quotes, switches to single quotes when there are\nmore double quotes in the string itself. ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," is best for gzip size."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1")," -- always use single quotes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2")," -- always use double quotes"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"3")," -- always use the original quotes"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"preserve_annotations")," -- (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- Preserve ",(0,i.kt)("a",{parentName:"p",href:"/docs/miscellaneous#annotations"},"Terser annotations")," in the output.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"safari10")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- set this option to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to work around\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://bugs.webkit.org/show_bug.cgi?id=176685"},"Safari 10/11 await bug"),".\nSee also: the ",(0,i.kt)("inlineCode",{parentName:"p"},"safari10")," ",(0,i.kt)("a",{parentName:"p",href:"/docs/options#mangle-options"},"mangle option"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"semicolons")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- separate statements with semicolons.  If\nyou pass ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," then whenever possible we will use a newline instead of a\nsemicolon, leading to more readable output of minified code (size before\ngzip could be smaller; size after gzip insignificantly larger).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"shebang")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- preserve shebang ",(0,i.kt)("inlineCode",{parentName:"p"},"#!")," in preamble (bash scripts)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"spidermonkey")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- produce a Spidermonkey (Mozilla) AST")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"webkit")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- enable workarounds for WebKit bugs.\nPhantomJS users should set this option to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"wrap_iife")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),") -- pass ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," to wrap immediately invoked\nfunction expressions. See\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/mishoo/UglifyJS2/issues/640"},"#640")," for more details.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"wrap_func_args")," (default ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),") -- pass ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," if you do not want to wrap\nfunction expressions that are passed as arguments, in parenthesis. See\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/nolanlawson/optimize-js"},"OptimizeJS")," for more details."))))}k.isMDXComponent=!0}}]);