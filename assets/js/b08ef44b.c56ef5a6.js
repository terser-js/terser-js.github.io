"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[857],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>g});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(t),d=o,g=u["".concat(l,".").concat(d)]||u[d]||c[d]||r;return t?a.createElement(g,i(i({ref:n},m),{},{components:t})):a.createElement(g,i({ref:n},m))}));function g(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6066:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=t(7462),o=(t(7294),t(3905));const r={id:"cli-usage",title:"CLI Usage",sidebar_label:"CLI Usage"},i=void 0,s={unversionedId:"cli-usage",id:"cli-usage",title:"CLI Usage",description:"Terser can take multiple input files.  It's recommended that you pass the",source:"@site/docs/cli-usage.md",sourceDirName:".",slug:"/cli-usage",permalink:"/docs/cli-usage",draft:!1,tags:[],version:"current",frontMatter:{id:"cli-usage",title:"CLI Usage",sidebar_label:"CLI Usage"},sidebar:"tutorialSidebar",previous:{title:"API Reference",permalink:"/docs/api-reference"},next:{title:"Miscellaneous",permalink:"/docs/miscellaneous"}},l={},p=[{value:"Command line options",id:"command-line-options",level:3},{value:"CLI source map options",id:"cli-source-map-options",level:2},{value:"Composed source map",id:"composed-source-map",level:3},{value:"CLI compress options",id:"cli-compress-options",level:2},{value:"CLI mangle options",id:"cli-mangle-options",level:2},{value:"CLI mangling property names (<code>--mangle-props</code>)",id:"cli-mangling-property-names---mangle-props",level:3},{value:"Mangling unquoted names (<code>--mangle-props keep_quoted</code>)",id:"mangling-unquoted-names---mangle-props-keep_quoted",level:3},{value:"Debugging property name mangling",id:"debugging-property-name-mangling",level:3}],m={toc:p},u="wrapper";function c(e){let{components:n,...t}=e;return(0,o.kt)(u,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"terser [input files] [options]\n")),(0,o.kt)("p",null,"Terser can take multiple input files.  It's recommended that you pass the\ninput files first, then pass the options.  Terser will parse input files\nin sequence and apply any compression options.  The files are parsed in the\nsame global scope, that is, a reference from a file to some\nvariable/function declared in another file will be matched properly."),(0,o.kt)("p",null,"Command line arguments that take options (like --parse, --compress, --mangle and\n--format) can take in a comma-separated list of default option overrides. For\ninstance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"terser input.js --compress ecma=2015,computed_props=false\n")),(0,o.kt)("p",null,"If no input file is specified, Terser will read from STDIN."),(0,o.kt)("p",null,"If you wish to pass your options before the input files, separate the two with\na double dash to prevent input files being used as option arguments:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"terser --compress --mangle -- input.js\n")),(0,o.kt)("h3",{id:"command-line-options"},"Command line options"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'    -h, --help                  Print usage information.\n                                `--help options` for details on available options.\n    -V, --version               Print version number.\n    -p, --parse <options>       Specify parser options:\n                                `acorn`  Use Acorn for parsing.\n                                `bare_returns`  Allow return outside of functions.\n                                                Useful when minifying CommonJS\n                                                modules and Userscripts that may\n                                                be anonymous function wrapped (IIFE)\n                                                by the .user.js engine `caller`.\n                                `expression`  Parse a single expression, rather than\n                                              a program (for parsing JSON).\n                                `spidermonkey`  Assume input files are SpiderMonkey\n                                                AST format (as JSON).\n    -c, --compress [options]    Enable compressor/specify compressor options:\n                                `pure_funcs`  List of functions that can be safely\n                                              removed when their return values are\n                                              not used.\n    -m, --mangle [options]      Mangle names/specify mangler options:\n                                `reserved`  List of names that should not be mangled.\n    --mangle-props [options]    Mangle properties/specify mangler options:\n                                `builtins`  Mangle property names that overlaps\n                                            with standard JavaScript globals and DOM\n                                            API props.\n                                `debug`  Add debug prefix and suffix.\n                                `keep_quoted`  Only mangle unquoted properties, quoted\n                                               properties are automatically reserved.\n                                               `strict` disables quoted properties\n                                               being automatically reserved.\n                                `regex`  Only mangle matched property names.\n                                `only_annotated` Only mangle properties defined with /*@__MANGLE_PROP__*/.\n                                `reserved`  List of names that should not be mangled.\n    -f, --format [options]      Specify format options.\n                                `preamble`  Preamble to prepend to the output. You\n                                            can use this to insert a comment, for\n                                            example for licensing information.\n                                            This will not be parsed, but the source\n                                            map will adjust for its presence.\n                                `quote_style`  Quote style:\n                                               0 - auto\n                                               1 - single\n                                               2 - double\n                                               3 - original\n                                `wrap_iife`  Wrap IIFEs in parenthesis. Note: you may\n                                             want to disable `negate_iife` under\n                                             compressor options.\n                                `wrap_func_args`  Wrap function arguments in parenthesis.\n    -o, --output <file>         Output file path (default STDOUT). Specify `ast` or\n                                `spidermonkey` to write Terser or SpiderMonkey AST\n                                as JSON to STDOUT respectively.\n    --comments [filter]         Preserve copyright comments in the output. By\n                                default this works like Google Closure, keeping\n                                JSDoc-style comments that contain e.g. "@license",\n                                or start with "!". You can optionally pass one of the\n                                following arguments to this flag:\n                                - "all" to keep all comments\n                                - `false` to omit comments in the output\n                                - a valid JS RegExp like `/foo/` or `/^!/` to\n                                keep only matching comments.\n                                Note that currently not *all* comments can be\n                                kept when compression is on, because of dead\n                                code removal or cascading statements into\n                                sequences.\n    --config-file <file>        Read `minify()` options from JSON file.\n    -d, --define <expr>[=value] Global definitions.\n    --ecma <version>            Specify ECMAScript release: 5, 2015, 2016, etc.\n    -e, --enclose [arg[:value]] Embed output in a big function with configurable\n                                arguments and values.\n    --ie8                       Support non-standard Internet Explorer 8.\n                                Equivalent to setting `ie8: true` in `minify()`\n                                for `compress`, `mangle` and `format` options.\n                                By default Terser will not try to be IE-proof.\n    --keep-classnames           Do not mangle/drop class names.\n    --keep-fnames               Do not mangle/drop function names.  Useful for\n                                code relying on Function.prototype.name.\n    --module                    Input is an ES6 module. If `compress` or `mangle` is\n                                enabled then the `toplevel` option will be enabled.\n    --name-cache <file>         File to hold mangled name mappings.\n    --safari10                  Support non-standard Safari 10/11.\n                                Equivalent to setting `safari10: true` in `minify()`\n                                for `mangle` and `format` options.\n                                By default `terser` will not work around\n                                Safari 10/11 bugs.\n    --source-map [options]      Enable source map/specify source map options:\n                                `base`  Path to compute relative paths from input files.\n                                `content`  Input source map, useful if you\'re compressing\n                                           JS that was generated from some other original\n                                           code. Specify "inline" if the source map is\n                                           included within the sources.\n                                `filename`  Name and/or location of the output source.\n                                `includeSources`  Pass this flag if you want to include\n                                                  the content of source files in the\n                                                  source map as sourcesContent property.\n                                `root`  Path to the original source to be included in\n                                        the source map.\n                                `url`  If specified, path to the source map to append in\n                                       `//# sourceMappingURL`.\n    --timings                   Display operations run time on STDERR.\n    --toplevel                  Compress and/or mangle variables in top level scope.\n    --wrap <name>               Embed everything in a big function, making the\n                                \u201cexports\u201d and \u201cglobal\u201d variables available. You\n                                need to pass an argument to this option to\n                                specify the name that your module will take\n                                when included in, say, a browser.\n')),(0,o.kt)("p",null,"Specify ",(0,o.kt)("inlineCode",{parentName:"p"},"--output")," (",(0,o.kt)("inlineCode",{parentName:"p"},"-o"),") to declare the output file.  Otherwise the output\ngoes to STDOUT."),(0,o.kt)("h2",{id:"cli-source-map-options"},"CLI source map options"),(0,o.kt)("p",null,"Terser can generate a source map file, which is highly useful for\ndebugging your compressed JavaScript.  To get a source map, pass\n",(0,o.kt)("inlineCode",{parentName:"p"},"--source-map --output output.js")," (source map will be written out to\n",(0,o.kt)("inlineCode",{parentName:"p"},"output.js.map"),")."),(0,o.kt)("p",null,"Additional options:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"--source-map \"filename='<NAME>'\"")," to specify the name of the source map.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"--source-map \"root='<URL>'\"")," to pass the URL where the original files can be found.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"--source-map \"url='<URL>'\"")," to specify the URL where the source map can be found.\nOtherwise Terser assumes HTTP ",(0,o.kt)("inlineCode",{parentName:"p"},"X-SourceMap")," is being used and will omit the\n",(0,o.kt)("inlineCode",{parentName:"p"},"//# sourceMappingURL=")," directive."))),(0,o.kt)("p",null,"For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"terser js/file1.js js/file2.js \\\n         -o foo.min.js -c -m \\\n         --source-map \"root='http://foo.com/src',url='foo.min.js.map'\"\n")),(0,o.kt)("p",null,"The above will compress and mangle ",(0,o.kt)("inlineCode",{parentName:"p"},"file1.js")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"file2.js"),", will drop the\noutput in ",(0,o.kt)("inlineCode",{parentName:"p"},"foo.min.js")," and the source map in ",(0,o.kt)("inlineCode",{parentName:"p"},"foo.min.js.map"),".  The source\nmapping will refer to ",(0,o.kt)("inlineCode",{parentName:"p"},"http://foo.com/src/js/file1.js")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"http://foo.com/src/js/file2.js")," (in fact it will list ",(0,o.kt)("inlineCode",{parentName:"p"},"http://foo.com/src"),"\nas the source map root, and the original files as ",(0,o.kt)("inlineCode",{parentName:"p"},"js/file1.js")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"js/file2.js"),")."),(0,o.kt)("h3",{id:"composed-source-map"},"Composed source map"),(0,o.kt)("p",null,"When you're compressing JS code that was output by a compiler such as\nCoffeeScript, mapping to the JS code won't be too helpful.  Instead, you'd\nlike to map back to the original code (i.e. CoffeeScript).  Terser has an\noption to take an input source map.  Assuming you have a mapping from\nCoffeeScript \u2192 compiled JS, Terser can generate a map from CoffeeScript \u2192\ncompressed JS by mapping every token in the compiled JS to its original\nlocation."),(0,o.kt)("p",null,"To use this feature pass ",(0,o.kt)("inlineCode",{parentName:"p"},"--source-map \"content='/path/to/input/source.map'\""),"\nor ",(0,o.kt)("inlineCode",{parentName:"p"},'--source-map "content=inline"')," if the source map is included inline with\nthe sources."),(0,o.kt)("h2",{id:"cli-compress-options"},"CLI compress options"),(0,o.kt)("p",null,"You need to pass ",(0,o.kt)("inlineCode",{parentName:"p"},"--compress")," (",(0,o.kt)("inlineCode",{parentName:"p"},"-c"),") to enable the compressor.  Optionally\nyou can pass a comma-separated list of ",(0,o.kt)("a",{parentName:"p",href:"/docs/api-reference#compress-options"},"compress options"),"."),(0,o.kt)("p",null,"Options are in the form ",(0,o.kt)("inlineCode",{parentName:"p"},"foo=bar"),", or just ",(0,o.kt)("inlineCode",{parentName:"p"},"foo")," (the latter implies\na boolean option that you want to set ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),"; it's effectively a\nshortcut for ",(0,o.kt)("inlineCode",{parentName:"p"},"foo=true"),")."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"terser file.js -c toplevel,sequences=false\n")),(0,o.kt)("h2",{id:"cli-mangle-options"},"CLI mangle options"),(0,o.kt)("p",null,"To enable the mangler you need to pass ",(0,o.kt)("inlineCode",{parentName:"p"},"--mangle")," (",(0,o.kt)("inlineCode",{parentName:"p"},"-m"),").  The following\n(comma-separated) options are supported:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"toplevel")," (default ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),") -- mangle names declared in the top level scope.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"eval")," (default ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),") -- mangle names visible in scopes where ",(0,o.kt)("inlineCode",{parentName:"p"},"eval")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"with")," are used."))),(0,o.kt)("p",null,"When mangling is enabled but you want to prevent certain names from being\nmangled, you can declare those names with ",(0,o.kt)("inlineCode",{parentName:"p"},"--mangle reserved")," \u2014 pass a\ncomma-separated list of names.  For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"terser ... -m reserved=['$','require','exports']\n")),(0,o.kt)("p",null,"to prevent the ",(0,o.kt)("inlineCode",{parentName:"p"},"require"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"exports")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," names from being changed."),(0,o.kt)("h3",{id:"cli-mangling-property-names---mangle-props"},"CLI mangling property names (",(0,o.kt)("inlineCode",{parentName:"h3"},"--mangle-props"),")"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," THIS ",(0,o.kt)("strong",{parentName:"p"},"WILL")," BREAK YOUR CODE. A good rule of thumb is not to use this unless you know exactly what you're doing and how this works and read this section until the end."),(0,o.kt)("p",null,"Mangling property names is a separate step, different from variable name mangling.  Pass\n",(0,o.kt)("inlineCode",{parentName:"p"},"--mangle-props")," to enable it. The least dangerous\nway to use this is to use the ",(0,o.kt)("inlineCode",{parentName:"p"},"regex")," option like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"terser example.js -c -m --mangle-props regex=/_$/\n")),(0,o.kt)("p",null,"This will mangle all properties that end with an\nunderscore. So you can use it to mangle internal methods."),(0,o.kt)("p",null,"By default, it will mangle all properties in the\ninput code with the exception of built in DOM properties and properties\nin core JavaScript classes, which is what will break your code if you don't:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Control all the code you're mangling"),(0,o.kt)("li",{parentName:"ol"},"Avoid using a module bundler, as they usually will call Terser on each file individually, making it impossible to pass mangled objects between modules."),(0,o.kt)("li",{parentName:"ol"},"Avoid calling functions like ",(0,o.kt)("inlineCode",{parentName:"li"},"defineProperty")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"hasOwnProperty"),", because they refer to object properties using strings and will break your code if you don't know what you are doing.")),(0,o.kt)("p",null,"An example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'// example.js\nvar x = {\n    baz_: 0,\n    foo_: 1,\n    calc: function() {\n        return this.foo_ + this.baz_;\n    }\n};\nx.bar_ = 2;\nx["baz_"] = 3;\nconsole.log(x.calc());\n')),(0,o.kt)("p",null,"Mangle all properties (except for JavaScript ",(0,o.kt)("inlineCode",{parentName:"p"},"builtins"),") (",(0,o.kt)("strong",{parentName:"p"},"very")," unsafe):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ terser example.js -c passes=2 -m --mangle-props\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"var x={o:3,t:1,i:function(){return this.t+this.o},s:2};console.log(x.i());\n")),(0,o.kt)("p",null,"Mangle all properties except for ",(0,o.kt)("inlineCode",{parentName:"p"},"reserved")," properties (still very unsafe):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ terser example.js -c passes=2 -m --mangle-props reserved=[foo_,bar_]\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"var x={o:3,foo_:1,t:function(){return this.foo_+this.o},bar_:2};console.log(x.t());\n")),(0,o.kt)("p",null,"Mangle all properties matching a ",(0,o.kt)("inlineCode",{parentName:"p"},"regex")," (not as unsafe but still unsafe):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ terser example.js -c passes=2 -m --mangle-props regex=/_$/\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"var x={o:3,t:1,calc:function(){return this.t+this.o},i:2};console.log(x.calc());\n")),(0,o.kt)("p",null,"Combining mangle properties options:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ terser example.js -c passes=2 -m --mangle-props regex=/_$/,reserved=[bar_]\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"var x={o:3,t:1,calc:function(){return this.t+this.o},bar_:2};console.log(x.calc());\n")),(0,o.kt)("p",null,"In order for this to be of any use, we avoid mangling standard JS names and DOM\nAPI properties by default (",(0,o.kt)("inlineCode",{parentName:"p"},"--mangle-props builtins")," to override)."),(0,o.kt)("p",null,"A regular expression can be used to define which property names should be\nmangled.  For example, ",(0,o.kt)("inlineCode",{parentName:"p"},"--mangle-props regex=/^_/")," will only mangle property\nnames that start with an underscore."),(0,o.kt)("p",null,"When you compress multiple files using this option, in order for them to\nwork together in the end we need to ensure somehow that one property gets\nmangled to the same name in all of them.  For this, pass ",(0,o.kt)("inlineCode",{parentName:"p"},"--name-cache filename.json"),"\nand Terser will maintain these mappings in a file which can then be reused.\nIt should be initially empty.  Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ rm -f /tmp/cache.json  # start fresh\n$ terser file1.js file2.js --mangle-props --name-cache /tmp/cache.json -o part1.js\n$ terser file3.js file4.js --mangle-props --name-cache /tmp/cache.json -o part2.js\n")),(0,o.kt)("p",null,"Now, ",(0,o.kt)("inlineCode",{parentName:"p"},"part1.js")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"part2.js")," will be consistent with each other in terms\nof mangled property names."),(0,o.kt)("p",null,"Using the name cache is not necessary if you compress all your files in a\nsingle call to Terser."),(0,o.kt)("h3",{id:"mangling-unquoted-names---mangle-props-keep_quoted"},"Mangling unquoted names (",(0,o.kt)("inlineCode",{parentName:"h3"},"--mangle-props keep_quoted"),")"),(0,o.kt)("p",null,"Using quoted property name (",(0,o.kt)("inlineCode",{parentName:"p"},'o["foo"]'),") reserves the property name (",(0,o.kt)("inlineCode",{parentName:"p"},"foo"),")\nso that it is not mangled throughout the entire script even when used in an\nunquoted style (",(0,o.kt)("inlineCode",{parentName:"p"},"o.foo"),"). Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'// stuff.js\nvar o = {\n    "foo": 1,\n    bar: 3\n};\no.foo += o.bar;\nconsole.log(o.foo);\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ terser stuff.js --mangle-props keep_quoted -c -m\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"var o={foo:1,o:3};o.foo+=o.o,console.log(o.foo);\n")),(0,o.kt)("h3",{id:"debugging-property-name-mangling"},"Debugging property name mangling"),(0,o.kt)("p",null,"You can also pass ",(0,o.kt)("inlineCode",{parentName:"p"},"--mangle-props debug")," in order to mangle property names\nwithout completely obscuring them. For example the property ",(0,o.kt)("inlineCode",{parentName:"p"},"o.foo"),"\nwould mangle to ",(0,o.kt)("inlineCode",{parentName:"p"},"o._$foo$_")," with this option. This allows property mangling\nof a large codebase while still being able to debug the code and identify\nwhere mangling is breaking things."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"$ terser stuff.js --mangle-props debug -c -m\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"var o={_$foo$_:1,_$bar$_:3};o._$foo$_+=o._$bar$_,console.log(o._$foo$_);\n")),(0,o.kt)("p",null,"You can also pass a custom suffix using ",(0,o.kt)("inlineCode",{parentName:"p"},"--mangle-props debug=XYZ"),". This would then\nmangle ",(0,o.kt)("inlineCode",{parentName:"p"},"o.foo")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"o._$foo$XYZ_"),". You can change this each time you compile a\nscript to identify how a property got mangled. One technique is to pass a\nrandom number on every compile to simulate mangling changing with different\ninputs (e.g. as you update the input script with new properties), and to help\nidentify mistakes like writing mangled keys to storage."))}c.isMDXComponent=!0}}]);